import numpy 
import logging 

from apgl.util.Parameter import Parameter
from exp.viroscopy.model.HIVGraph import HIVGraph 
from exp.sandbox.GraphMatch import GraphMatch 

class HIVGraphMetrics(object): 
    def __init__(self, times):
        """
        A class to model metrics about and between HIVGraphs such as summary 
        statistics and distances. 
        
        :param times: An array of time points to compute statistics from 
        """
        
        self.times = times 

    def summary(self, graph): 
        """
        Compute a summary statistic on the input HIV graph         
        """
        Parameter.checkClass(graph, HIVGraph)
        summaryArray = numpy.zeros((self.times.shape[0], 2))

        for i in range(self.times.shape[0]): 
            t = self.times[i]
            subgraph = graph.subgraph(graph.infectedIndsAt(t))    
        
            summaryArray[i, :] = numpy.array([subgraph.getNumVertices(), subgraph.getNumEdges()])        
        
        return summaryArray
    
    def distance(self, summary1, summary2): 
        """
        Take as input two summary statistics computed on HIV graphs, and output 
        a distance metric.
        
        :param summary1: A summary statistic for a desired HIVGraph. 
        
        :param summary2: A summary statistic for a modelled HIVGraph. 
        """        
        return numpy.linalg.norm(summary1 - summary2)
        
    def shouldBreak(self, realSummary, graph, epsilon, currentTime): 
        """
        Given a summary statistic realSummary, a graph created by the model and 
        a value of epsilon return True if the distance has exceeded epsilon 
        otherwise False. 

        :param realSummary: Summary statistic computed on real data 
        
        :param graph: The HIVGraph generated by the model. 
        :type graph: `exp.viroscopy.model.HIVGraph`
        
        :param epsilon: The maximum distance to be accepted. 
        
        """
        newTimes = self.times[self.times <= currentTime]
        summaryStat = self.summary(graph)
        
        realSummary = realSummary[0:newTimes.shape[0]]
        summaryStat = HIVGraphMetrics(newTimes).summary(graph)

        dist = self.distance(summaryStat, realSummary)
        
        if dist >= epsilon:
            logging.debug("Distance is " + str(dist) +  " and epsilon is " + str(epsilon))
            return True
        else:
            return False  
            
class HIVGraphMetrics2(object): 
    def __init__(self, times, matcher=None):
        """
        A class to model metrics about and between HIVGraphs such as summary 
        statistics and distances. In this case we perform graph matching 
        using the PATH algorithm and other graph matching methods. 
        
        :param times: An array of time points to compute statistics from 
        """
        
        self.times = times 
        
        if matcher == None: 
            self.matcher = GraphMatch("U")
        else: 
            self.matcher = matcher 
        
    def summary(self, graph): 
        """
        Compute a summary statistic on the input HIV graph. In this case, it is 
        just the graphs at each time point until the last infection/detection 
        of the graph. 
        """
        summaryList = [] 
        
        endTimeInd = numpy.sum(self.times <= graph.endTime()) + 1
        times = self.times[0:endTimeInd]

        for i in range(times.shape[0]): 
            t = times[i] 
            logging.debug("Computing summary at time " + str(t))
            subgraph = graph.subgraph(graph.removedIndsAt(t))   
            summaryList.append(subgraph)
        
        return summaryList 
        
    def distance(self, summary1, summary2):
        """
        Take as input two summary statistics computed at various time points on 
        HIV graphs, and output a distance metric which uses the matching algorithm 
        passed into the contructor. Note that the distance between two identical 
        graphs is not zero. 
        
        :param summary1: A desired list of HIVGraphs. 
        
        :param summary2: A modelled list of HIVGraphs. 
        """ 
        totalDist = 0 
        logging.debug("Computing total distance")
        for i in range(numpy.min(numpy.array([len(summary1), len(summary2)]))): 
            logging.debug("Time = " + str(self.times[i]) + " sizes = " + str(summary1[i].size) + ", " + str(summary2[i].size))
            permutation, distance, time = self.matcher.match(summary1[i], summary2[i])
            lastDist = self.matcher.distance(summary1[i], summary2[i], permutation, True, True) 
            totalDist += lastDist
            logging.debug("Distance = " + str(lastDist))
            
        #If one summary stat is too small we extend it to be the same length as the other one 
        #by copying the last value (using the same distance)
        for j in range(i, self.times.shape[0]): 
            totalDist += lastDist 
        
        logging.debug("Computed total distance as " + str(totalDist))
        return totalDist 
        
    def shouldBreak(self, realSummary, graph, epsilon, currentTime): 
        """
        Given a summary statistic realSummary, a graph created by the model and 
        a value of epsilon return True if the distance has exceeded epsilon 
        otherwise False. 

        :param realSummary: Summary statistic computed on real data 
        
        :param graph: The HIVGraph generated by the model. 
        :type graph: `exp.viroscopy.model.HIVGraph`
        
        :param epsilon: The maximum distance to be accepted. 
        
        """
        newTimes = self.times[self.times <= currentTime]

        tempMetrics = HIVGraphMetrics2(newTimes)
        realSummary = realSummary[0:newTimes.shape[0]]
        summaryStat = tempMetrics.summary(graph)

        dist = tempMetrics.distance(summaryStat, realSummary)
        
        if dist >= epsilon:
            logging.debug("Distance is " + str(dist) +  " and epsilon is " + str(epsilon))
            return True
        else:
            return False  